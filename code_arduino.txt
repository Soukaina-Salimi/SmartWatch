#include <Arduino.h>
#include <Wire.h>
#include "MAX30105.h"
#include "heartRate.h"
#include <MPU6050.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <BLEDevice.h>
#include <BLEUtils.h>
#include <BLEServer.h>

// ESP32-C3 Pin Definitions
#define I2C_SDA 1    // GPIO1 for SDA
#define I2C_SCL 2    // GPIO2 for SCL  
#define BUTTON_PIN 9  // GPIO9 for button

// OLED Display Configuration
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// Button Configuration
volatile int displayMode = 0;
const int MAX_DISPLAY_MODES = 3;
volatile unsigned long lastButtonPress = 0;
const unsigned long DEBOUNCE_DELAY = 500;

// Sensor Objects
MAX30105 particleSensor;
MPU6050 mpu;

// Global Data
volatile bool fingerDetected = false;
volatile long irValue = 0;
volatile float heartRate = 0.0;
volatile long lastBeat = 0;
volatile float signalQuality = 0.0;
volatile float accelX = 0, accelY = 0, accelZ = 0;
volatile float gyroX = 0, gyroY = 0, gyroZ = 0;
volatile unsigned long systemTime = 0;

// Heart rate algorithm
const byte RATE_SIZE = 8;
byte rates[RATE_SIZE];
byte rateSpot = 0;
float beatsPerMinute;
int beatAvg;
bool beatDetected = false;

// Signal processing
long lastIrValue = 0;

// BLE Configuration
BLEServer* pServer = NULL;
BLECharacteristic* pHeartRateCharacteristic = NULL;
BLECharacteristic* pAccelerometerCharacteristic = NULL;
BLECharacteristic* pGyroscopeCharacteristic = NULL;
BLECharacteristic* pSignalQualityCharacteristic = NULL;

bool deviceConnected = false;
bool oldDeviceConnected = false;

#define SERVICE_UUID        "4fafc201-1fb5-459e-8fcc-c5c9c331914b"
#define HEART_RATE_UUID     "beb5483e-36e1-4688-b7f5-ea07361b26a8"
#define ACCELEROMETER_UUID  "beb5483f-36e1-4688-b7f5-ea07361b26a8"
#define GYROSCOPE_UUID      "beb54840-36e1-4688-b7f5-ea07361b26a8"
#define SIGNAL_QUALITY_UUID "beb54841-36e1-4688-b7f5-ea07361b26a8"

class MyServerCallbacks: public BLEServerCallbacks {
    void onConnect(BLEServer* pServer) {
        deviceConnected = true;
        Serial.println("üì± BLE Device Connected");
    };

    void onDisconnect(BLEServer* pServer) {
        deviceConnected = false;
        Serial.println("üì± BLE Device Disconnected");
    }
};

void setupBLE() {
    Serial.println("üîß Initializing BLE...");
    
    BLEDevice::init("ESP32-C3 Health Monitor");
    pServer = BLEDevice::createServer();
    pServer->setCallbacks(new MyServerCallbacks());
    
    BLEService *pService = pServer->createService(SERVICE_UUID);
    
    // Heart Rate Characteristic
    pHeartRateCharacteristic = pService->createCharacteristic(
        HEART_RATE_UUID,
        BLECharacteristic::PROPERTY_READ |
        BLECharacteristic::PROPERTY_NOTIFY
    );
    
    // Accelerometer Characteristic
    pAccelerometerCharacteristic = pService->createCharacteristic(
        ACCELEROMETER_UUID,
        BLECharacteristic::PROPERTY_READ |
        BLECharacteristic::PROPERTY_NOTIFY
    );
    
    // Gyroscope Characteristic
    pGyroscopeCharacteristic = pService->createCharacteristic(
        GYROSCOPE_UUID,
        BLECharacteristic::PROPERTY_READ |
        BLECharacteristic::PROPERTY_NOTIFY
    );
    
    // Signal Quality Characteristic
    pSignalQualityCharacteristic = pService->createCharacteristic(
        SIGNAL_QUALITY_UUID,
        BLECharacteristic::PROPERTY_READ |
        BLECharacteristic::PROPERTY_NOTIFY
    );
    
    pService->start();
    
    BLEAdvertising *pAdvertising = BLEDevice::getAdvertising();
    pAdvertising->addServiceUUID(SERVICE_UUID);
    pAdvertising->setScanResponse(true);
    pAdvertising->setMinPreferred(0x06);
    pAdvertising->setMinPreferred(0x12);
    BLEDevice::startAdvertising();
    
    Serial.println("‚úÖ BLE Ready - Device: 'ESP32-C3 Health Monitor'");
}

void updateBLE() {
    if (deviceConnected) {
        // Send Heart Rate
        String hrData = String(heartRate, 1);
        pHeartRateCharacteristic->setValue(hrData.c_str());
        pHeartRateCharacteristic->notify();
        
        // Send Accelerometer Data
        String accelData = String(accelX, 2) + "," + String(accelY, 2) + "," + String(accelZ, 2);
        pAccelerometerCharacteristic->setValue(accelData.c_str());
        pAccelerometerCharacteristic->notify();
        
        // Send Gyroscope Data
        String gyroData = String(gyroX, 1) + "," + String(gyroY, 1) + "," + String(gyroZ, 1);
        pGyroscopeCharacteristic->setValue(gyroData.c_str());
        pGyroscopeCharacteristic->notify();
        
        // Send Signal Quality
        String sqData = String(signalQuality, 1);
        pSignalQualityCharacteristic->setValue(sqData.c_str());
        pSignalQualityCharacteristic->notify();
    }
    
    // Handle disconnection
    if (!deviceConnected && oldDeviceConnected) {
        delay(500);
        pServer->startAdvertising();
        Serial.println("üì± BLE Advertising started");
        oldDeviceConnected = deviceConnected;
    }
    
    // Handle connection
    if (deviceConnected && !oldDeviceConnected) {
        oldDeviceConnected = deviceConnected;
    }
}

void IRAM_ATTR handleButtonPress() {
    unsigned long currentTime = millis();
    if (currentTime - lastButtonPress > DEBOUNCE_DELAY) {
        displayMode = (displayMode + 1) % MAX_DISPLAY_MODES;
        lastButtonPress = currentTime;
        Serial.print("üîÑ Display Mode Changed to: ");
        Serial.println(displayMode);
    }
}

bool initializeSensors() {
    Serial.println("üîß Initializing I2C for ESP32-C3...");
    
    Wire.begin(I2C_SDA, I2C_SCL);
    Wire.setClock(400000);
    
    delay(100);
    
    // Initialize MAX30102
    Serial.println("üîß Initializing MAX30102...");
    if (!particleSensor.begin(Wire, I2C_SPEED_FAST)) {
        Serial.println("‚ùå MAX30102 not found!");
        return false;
    }
    
    // Conservative settings
    byte ledBrightness = 0x0F;
    byte sampleAverage = 4;
    byte ledMode = 2;
    int sampleRate = 100;
    int pulseWidth = 69;
    int adcRange = 4096;
    
    particleSensor.setup(ledBrightness, sampleAverage, ledMode, sampleRate, pulseWidth, adcRange);
    particleSensor.setPulseAmplitudeRed(0x02);
    particleSensor.setPulseAmplitudeIR(0x02);
    particleSensor.enableDIETEMPRDY();
    
    Serial.println("‚úÖ MAX30102 initialized");
    
    // Initialize MPU6050
    mpu.initialize();
    if (mpu.testConnection()) {
        Serial.println("‚úÖ MPU6050 connected");
    }
    
    // Initialize OLED
    if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
        Serial.println("‚ùå OLED not found");
        return false;
    }
    display.clearDisplay();
    display.setTextColor(SSD1306_WHITE);
    display.setTextSize(1);
    display.setCursor(0,0);
    display.println("FIXED DETECTION");
    display.println("IR > 1000 = FINGER");
    display.display();
    delay(2000);
    
    return true;
}

// SIMPLE finger detection - no debounce issues
bool checkFingerDetected(long ir) {
    // SIMPLE THRESHOLD - if IR > 1000, finger is detected
    return (ir > 1000);
}

float calculateSignalQuality(long currentIR, long previousIR) {
    if (previousIR == 0 || !fingerDetected) return 0.0;
    
    long variation = abs(currentIR - previousIR);
    float quality = (variation / 500.0f) * 100.0f;
    
    if (quality < 0) quality = 0;
    if (quality > 100) quality = 100;
    
    return quality;
}

void updateHeartRate() {
    long currentIR = particleSensor.getIR();
    irValue = currentIR;
    
    // SIMPLE finger detection - direct assignment
    bool newFingerDetected = checkFingerDetected(currentIR);
    
    // Only print when state changes
    if (newFingerDetected != fingerDetected) {
        fingerDetected = newFingerDetected;
        if (fingerDetected) {
            Serial.println("üéØ FINGER DETECTED!");
            Serial.print("IR Value: ");
            Serial.println(currentIR);
            // Reset heart rate algorithm
            lastBeat = 0;
            for(byte x = 0 ; x < RATE_SIZE ; x++) rates[x] = 0;
            rateSpot = 0;
            beatAvg = 0;
            heartRate = 0.0;
        } else {
            Serial.println("üëã FINGER REMOVED");
            heartRate = 0.0;
        }
    }
    
    if (fingerDetected) {
        // Calculate signal quality
        signalQuality = calculateSignalQuality(currentIR, lastIrValue);
        lastIrValue = currentIR;
        
        // Use library's beat detection
        beatDetected = checkForBeat(currentIR);
        
        if (beatDetected) {
            long delta = millis() - lastBeat;
            lastBeat = millis();
            
            if (delta > 300 && delta < 1500) {
                beatsPerMinute = 60000.0 / delta;
                
                if (beatsPerMinute >= 40 && beatsPerMinute <= 180) {
                    rates[rateSpot++] = (byte)beatsPerMinute;
                    rateSpot %= RATE_SIZE;
                    
                    // Calculate average
                    beatAvg = 0;
                    int validReadings = 0;
                    for (byte x = 0 ; x < RATE_SIZE ; x++) {
                        if (rates[x] > 0) {
                            beatAvg += rates[x];
                            validReadings++;
                        }
                    }
                    
                    if (validReadings > 0) {
                        beatAvg /= validReadings;
                        heartRate = beatAvg;
                        
                        Serial.print("üíì BEAT! BPM: ");
                        Serial.print(heartRate, 1);
                        Serial.print(" | IBI: ");
                        Serial.print(delta);
                        Serial.print("ms");
                        Serial.println();
                    }
                }
            }
        }
    } else {
        signalQuality = 0.0;
        heartRate = 0.0;
        beatDetected = false;
    }
}

void updateMotionSensor() {
    int16_t ax, ay, az;
    int16_t gx, gy, gz;
    
    mpu.getAcceleration(&ax, &ay, &az);
    mpu.getRotation(&gx, &gy, &gz);
    
    accelX = ax / 16384.0;
    accelY = ay / 16384.0;
    accelZ = az / 16384.0;
    
    gyroX = gx / 131.0;
    gyroY = gy / 131.0;
    gyroZ = gz / 131.0;
}

void updateDisplay() {
    display.clearDisplay();
    display.setCursor(0,0);
    display.setTextSize(1);
    
    switch(displayMode) {
        case 0:
            display.println("HEART RATE");
            break;
        case 1:
            display.println("MOTION DATA");
            break;
        case 2:
            display.println("DEBUG INFO");
            break;
    }
    
    display.drawFastHLine(0, 10, 128, SSD1306_WHITE);
    display.setCursor(0, 12);
    
    if (displayMode == 0) {
        display.print("IR: ");
        display.println(irValue);
        display.print("Finger: ");
        if (fingerDetected) {
            display.println("‚úÖ DETECTED");
            if (heartRate > 0) {
                display.setTextSize(2);
                display.print("BPM: ");
                display.println(heartRate, 0);
                display.setTextSize(1);
                display.print("Quality: ");
                display.print(signalQuality, 1);
                display.println("%");
            } else {
                display.println("Finding pulse...");
            }
        } else {
            display.println("‚ùå NOT DETECTED");
            display.println("IR > 1000 = finger");
        }
    }
    else if (displayMode == 1) {
        display.print("Accel X: "); display.println(accelX, 2);
        display.print("Accel Y: "); display.println(accelY, 2);
        display.print("Accel Z: "); display.println(accelZ, 2);
        display.print("Gyro X: "); display.println(gyroX, 1);
        display.print("Gyro Y: "); display.println(gyroY, 1);
    }
    else if (displayMode == 2) {
        display.println("SENSOR STATUS");
        display.print("IR Value: ");
        display.println(irValue);
        display.print("Threshold: >1000");
        display.setCursor(0, 30);
        display.print("Finger: ");
        if (fingerDetected) {
            display.println("‚úÖ YES");
        } else {
            display.println("‚ùå NO");
        }
        display.print("HR: ");
        display.print(heartRate, 1);
        display.println(" BPM");
        display.print("Time: ");
        display.print(systemTime);
        display.println("s");
        display.print("BLE: ");
        display.println(deviceConnected ? "CONNECTED" : "DISCONNECTED");
    }
    
    display.setCursor(0, 56);
    display.print("Mode ");
    display.print(displayMode + 1);
    
    display.display();
}

void printSerialData() {
    Serial.print("=== SYSTEM == Time: ");
    Serial.print(systemTime);
    Serial.print("s | IR: ");
    Serial.print(irValue);
    
    // DEBUG: Show what the detection logic sees
    Serial.print(" | Threshold: >1000");
    Serial.print(" | Finger: ");
    Serial.print(fingerDetected ? "YES" : "NO");
    
    if (fingerDetected) {
        Serial.print(" | BPM: ");
        Serial.print(heartRate, 1);
        Serial.print(" | Quality: ");
        Serial.print(signalQuality, 1);
        Serial.print("%");
    }
    
    Serial.print(" | BLE: ");
    Serial.print(deviceConnected ? "CONNECTED" : "DISCONNECTED");
    
    Serial.println();
}

void setup() {
    Serial.begin(115200);
    delay(2000);
    
    Serial.println("\n\nüöÄ ESP32-C3 FIXED FINGER DETECTION");
    Serial.println("üîß Simple Threshold: IR > 1000 = FINGER");
    
    pinMode(BUTTON_PIN, INPUT_PULLUP);
    attachInterrupt(digitalPinToInterrupt(BUTTON_PIN), handleButtonPress, FALLING);
    
    if (!initializeSensors()) {
        Serial.println("‚ùå Sensor initialization failed!");
        while(1) {
            display.clearDisplay();
            display.setCursor(0,0);
            display.println("SENSOR ERROR");
            display.display();
            delay(1000);
        }
    }
    
    // Initialize BLE
    setupBLE();
    
    for(byte x = 0 ; x < RATE_SIZE ; x++) {
        rates[x] = 0;
    }
    
    Serial.println("‚úÖ System ready - Testing finger detection");
    Serial.println("üéØ IR > 1000 should detect finger");
}

void loop() {
    static unsigned long lastSensorUpdate = 0;
    static unsigned long lastDisplayUpdate = 0;
    static unsigned long lastSerialUpdate = 0;
    static unsigned long lastBLEUpdate = 0;
    
    unsigned long currentTime = millis();
    systemTime = currentTime / 1000;
    
    if (currentTime - lastSensorUpdate >= 20) {
        lastSensorUpdate = currentTime;
        updateHeartRate();
        updateMotionSensor();
    }
    
    if (currentTime - lastDisplayUpdate >= 200) {
        lastDisplayUpdate = currentTime;
        updateDisplay();
    }
    
    if (currentTime - lastSerialUpdate >= 1000) {
        lastSerialUpdate = currentTime;
        printSerialData();
    }
    
    if (currentTime - lastBLEUpdate >= 100) {
        lastBLEUpdate = currentTime;
        updateBLE();
    }
    
    delay(10);
}